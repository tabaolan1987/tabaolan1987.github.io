<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Webdriver | Ta Bao Lan Software Engineer - Test Automation Engineer]]></title>
  <link href="http://tabaolan1987.github.io/blog/categories/webdriver/atom.xml" rel="self"/>
  <link href="http://tabaolan1987.github.io/"/>
  <updated>2014-05-29T11:16:36+07:00</updated>
  <id>http://tabaolan1987.github.io/</id>
  <author>
    <name><![CDATA[Ta Bao Lan]]></name>
    <email><![CDATA[tabaolan1987@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Webdriver : Dropdown and Multiple Select Operations]]></title>
    <link href="http://tabaolan1987.github.io/blog/2014/05/26/webdriver-dropdown-and-multiple-select-operations/"/>
    <updated>2014-05-26T10:15:16+07:00</updated>
    <id>http://tabaolan1987.github.io/blog/2014/05/26/webdriver-dropdown-and-multiple-select-operations</id>
    <content type="html"><![CDATA[<h2>DropDown &amp; Multiple Select Operations</h2>

<p>Just like Checkboxes &amp; Radio buttons, Dropdown and Multiple Select also works together and almost the same way. To perform any action, the first task is to identify the element group. I am saying it a group, as dropdown/multiple select is not a single element. They always have a single name but and they contains one or more than one elements in them. I should rather say more than one option in dropdown and multiple select. The only difference between these two is deselecting statement &amp; multiple selections are not allowed on dropdowns. Let’s look at the different operations:</p>

<!--more-->


<h3>Selecting Dropdown/Multiple Select Box</h3>

<p>It is just an ordinary operation like selecting any other type of element on a webpage. You can choose it by ID, Name, Css &amp; Xpath etc. But to perform any action on this element it is required to import ‘import org.openqa.selenium.support.ui.Select' package and to use it we need to create a new select object of class select.</p>

<p><code>
Select oSelection = new Select(driver.findElement(By.id(id)));
</code></p>

<p>Note: Select class only works for elements with select tags</p>

<h3>Selecting an option using ‘selectByVisibleText’</h3>

<p>It is very easy to choose or select an option given under any dropdowns and multiple selection boxes with selectByVisibleText method.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));
oSelection.selectByVisibleText(text);</p>

<p>```</p>

<h3>Selecting an option using ‘selectByIndex’</h3>

<p>It is almost the same as selectByVisibleText but the only difference here is that we provide the index number of the option here rather the option text.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));</p>

<p>oSelection.selectByIndex(index);
```</p>

<h3>Selecting an option using ‘selectByValue’</h3>

<p>It is again the same what we have discussed earlier, the only difference in this is that we need to provide the value of the option rather the option text.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));
oSelection.selectByValue(value);</p>

<p>```</p>

<p>Note: The value of an option and the text of the option may not be always same and there can be a possibility that the value is not assigned to Select webelement. If the value is given in the Select tag then only you can use the selectByValue method.</p>

<h3>Getting the Size of Select item</h3>

<p>Sometimes you may like to count the element in the dropdown and multiple select box, so that you can use the loop on Select element.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));
List<WebElement> oSize = oSelection.getOptions();
int iListSize = oSize.size();</p>

<p>```</p>

<h3>Printing the Options</h3>

<p>Once you get the size of the Select element then it is easy to print the Text of the options.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));</p>

<pre><code>List oSize = oSelection.getOptions();
int iListSize = oSize.size();
for(int i =0; i&gt;iListSize ; i++){
    String sValue = oSelection.getOptions().get(i).getText();
    System.out.println(sValue);
    }
</code></pre>

<p>```</p>

<p>All of the above methods work on both Dropdown and Multiple select box.</p>

<h3>Deselect methods</h3>

<p>This only works on Multiple selection boxes. If in case you want to deselect any selected option and that can be done with either deselectAll(), deselectByIndex, deselectByValue and deselectByVisibletext.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));</p>

<pre><code>oSelection.deselectAll();
oSelection.deselectByIndex(index);
oSelection.deselectByValue(value);
oSelection.deselectByVisibleText(text);
</code></pre>

<p>```</p>

<h3>Multiple selection method</h3>

<p>This one also just works on Multiple selection boxes and not on regular List boxes or dropdowns. There is no additional logic behind selecting multiple options of Select element. All you need to do is to fire select commands on multiple elements one by one that’s it.</p>

<p>```
Select oSelection = new Select(driver.findElement(By.id(id)));</p>

<pre><code>oSelection.selectByIndex(index)
oSelection.selectByIndex(index)
// Or
oSelection.selectByVisibleText(text)
oSelection.selectByVisibleText(text)
// Or
oSelection.selectByValue(value)
oSelection.selectByValue(value)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webdriver : Checkbox and Radio Button Operations]]></title>
    <link href="http://tabaolan1987.github.io/blog/2014/05/26/webdriver-checkbox-and-radio-button-operations/"/>
    <updated>2014-05-26T10:10:11+07:00</updated>
    <id>http://tabaolan1987.github.io/blog/2014/05/26/webdriver-checkbox-and-radio-button-operations</id>
    <content type="html"><![CDATA[<h2>CheckBox &amp; Radio Button Operations</h2>

<p>Operations on Checkboxes and Radio Buttons are easy to perform and most of the times the simple ID attributes work fine for both of these. But selection and d-selection is not the only thing we want with checkboxes and radio buttons. We might like to check that if the checkbox is already checked or if the radio button is selected by default or anything. Checkboxes and Radio button deals exactly the same way and you can perform below mentioned operations on either of them.</p>

<!--more-->


<h3>Different Selection Method</h3>

<h4>By ID</h4>

<p>If ID is given for the radio button/checkbox and you just want to click the radio button/checkbox Irrespective of its value, then the command will be like this:</p>

<p><code>
WebElement radioBtn = driver.findElement(By.id("toolsqa"));
radioBtn.click();
</code></p>

<h4>With ‘IsSelected’</h4>

<p>If your choice is based on the pre-selection of the Radio button/Checkbox and you just need to select the deselected radio button/checkbox. Assume there are two radio buttons/checkboxes, one is selected by default and you want to select the other one for your test. With IsSelected statement, you can get to know that the radio button or the check box is selected or not.</p>

<p>```
 // Store all the elements of same category in the list of WebLements <br/>
 List  oRadioButton = driver.findElements(By.name(&ldquo;toolsqa&rdquo;));</p>

<p> // Create a boolean variable which will hold the value (True/False)
 boolean bValue = false;</p>

<p> // This statement will return True, in case of first Radio button is selected
 bValue = oRadioButton.get(0).isSelected();</p>

<p> // This will check that if the bValue is True means if the first radio button is selected
 if(bValue = true){</p>

<pre><code>// This will select Second radio button, if the first radio button is selected by default
oRadioButton.get(1).click();
</code></pre>

<p> }else{</p>

<pre><code>// If the first radio button is not selected by default, the first will be selected
oRadioButton.get(0).click();
</code></pre>

<p> }</p>

<p>```</p>

<p>Note: Name is always same for the same group of radio buttons/checkboxes but their Values are different. So if you find the checkbox/radio button element with the name attribute then it means that it may contain more than one element, hence we need to use findElements method and store it the list of WebElements.</p>

<h3>With ‘Value’</h3>

<p>You can even select Radio buttons/Checkboxes with their Values.</p>

<p>```
// Find the checkbox or radio button element by Name
 List oCheckBox = driver.findElements(By.name(&ldquo;example&rdquo;));</p>

<p> // This will tell you the number of checkboxes are present
 int iSize = oCheckBox.size();</p>

<p> // Start the loop from first checkbox to last checkboxe
 for(int i=0; i &lt; iSize ; i++ ){</p>

<pre><code> // Store the checkbox name to the string variable, using 'Value' attribute
 String sValue = oCheckBox.get(i).getAttribute("value");

 // Select the checkbox it the value of the checkbox is same what you are looking for
 if (sValue.equalsIgnoreCase("your value")){
     oCheckBox.get(i).click();

     // This will take the execution out of for loop
     break;
     }
}
</code></pre>

<p>```</p>

<h3>By ‘CssSelector’</h3>

<p>A simple way of selecting a check-box or radio button is by using its value:</p>

<p><code>
WebElement oCheckBox = driver.findElement(By.cssSelector("input[value='example']"));
oCheckBox.click();
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webdriver : Wait Commands]]></title>
    <link href="http://tabaolan1987.github.io/blog/2014/05/26/webdriver-wait-commands/"/>
    <updated>2014-05-26T10:03:49+07:00</updated>
    <id>http://tabaolan1987.github.io/blog/2014/05/26/webdriver-wait-commands</id>
    <content type="html"><![CDATA[<h2>WebDriver Wait Commands</h2>

<p>Listing out the different WebDriver Wait statements that can be useful for an effective scripting and can avoid using the Thread.sleep() commands.</p>

<!--more-->


<h3>ImplicitlyWait Command</h3>

<p>Purpose: Selenium WebDriver has borrowed the idea of implicit waits from Watir. This means that we can tell Selenium that we would like it to wait for a certain amount of time before throwing an exception that it cannot find the element on the page. We should note that implicit waits will be in place for the entire time the browser is open. This means that any search for elements on the page could take the time the implicit wait is set for.</p>

<p>```</p>

<p> WebDriver driver => new FirefoxDriver();
 driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
 driver.get(&ldquo;<a href="http://url_that_delays_loading">http://url_that_delays_loading</a>&rdquo;);
 WebElement myDynamicElement = driver.findElement(By.id(&ldquo;myDynamicElement&rdquo;));</p>

<p>```</p>

<h3>FluentWait Command</h3>

<p>Purpose: Each FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition. Furthermore, the user may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementExceptions when searching for an element on the page.</p>

<p>```
// Waiting 30 seconds for an element to be present on the page, checking
  // for its presence once every 5 seconds.
  Wait wait = new FluentWait(driver)</p>

<pre><code>.withTimeout(30, SECONDS)
.pollingEvery(5, SECONDS)
.ignoring(NoSuchElementException.class);
</code></pre>

<p>  WebElement foo = wait.until(new Function() {</p>

<pre><code>public WebElement apply(WebDriver driver) {
return driver.findElement(By.id("foo"));
}
</code></pre>

<p>   });</p>

<p>```</p>

<h3>ExpectedConditions Command</h3>

<p>Purpose: Models a condition that might reasonably be expected to eventually evaluate to something that is neither null nor false.</p>

<p><code>
WebDriverWait wait = new WebDriverWait(driver, 10);
WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id(&gt;someid&gt;)));
</code></p>

<h3>PageLoadTimeout Command</h3>

<p>Purpose: Sets the amount of time to wait for a page load to complete before throwing an error. If the timeout is negative, page loads can be indefinite.</p>

<p><code>
driver.manage().timeouts().pageLoadTimeout(100, SECONDS);
</code></p>

<h3>SetScriptTimeout Command</h3>

<p>Purpose: Sets the amount of time to wait for an asynchronous script to finish execution before throwing an error. If the timeout is negative, then the script will be allowed to run indefinitely.</p>

<p><code>
driver.manage().timeouts().setScriptTimeout(100,SECONDS);
</code></p>

<h3>Sleep Command</h3>

<p>Purpose: This is rarely used, as it always force the browser to wait for a specific time. Thread.Sleep is never a good idea and that’s why Selenium provides wait primitives. If you use them you can specify much higher timeout value which makes tests more reliable without slowing them down as the condition can be evaluated as often as it’s required.</p>

<p><code>
thread.sleep(1000);
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webdriver : Switch Window Commands]]></title>
    <link href="http://tabaolan1987.github.io/blog/2014/05/26/webdriver-switch-window-commands/"/>
    <updated>2014-05-26T09:02:20+07:00</updated>
    <id>http://tabaolan1987.github.io/blog/2014/05/26/webdriver-switch-window-commands</id>
    <content type="html"><![CDATA[<h2>WebDriver Switch Window Commands</h2>

<p>Some web applications have many frames or multiple windows. Selenium WebDriver assigns an alphanumeric id to each window as soon as the WebDriver object is instantiated. This unique alphanumeric id is called window handle. Selenium uses this unique id to switch control among several windows. In simple terms, each unique window has a unique ID, so that Selenium can differentiate when it is switching controls from one window to the other.</p>

<!--more-->


<h3>GetWindowHandle Command</h3>

<p>Purpose: To get the window handle of the current window.</p>

<p><code>
String  handle= driver.getWindowHandle();//Return a string of alphanumeric window handle
</code></p>

<h3>GetWindowHandles Command</h3>

<p>Purpose: To get the window handle of all the current windows.</p>

<p><code>
Set&lt;String&gt; handle= driver.getWindowHandles();//Return a set of window handle
</code></p>

<h3>SwitchTo Window Command</h3>

<p>Purpose: WebDriver supports moving between named windows using the “switchTo” method.</p>

<p>```
driver.switchTo().window(&ldquo;windowName&rdquo;);</p>

<p>```</p>

<p>Alternatively, you can pass a “window handle” to the “switchTo().window()” method. Knowing this, it’s possible to iterate over every open window like so:</p>

<p>```
for (String handle : driver.getWindowHandles()) {</p>

<pre><code>driver.switchTo().window(handle);
</code></pre>

<p>}</p>

<p>```</p>

<p>Switching between windows with Iterators:</p>

<p>```</p>

<p>driver.findElement(By.id(“id of the link which opens new window”)).click();
 //wait till two windows are not opened
 waitForNumberofWindowsToEqual(2);//this method is for wait</p>

<p> Set handles = driver.getWindowHandles();
 firstWinHandle = driver.getWindowHandle(); handles.remove(firstWinHandle);
 String winHandle=handles.iterator().next();
 if (winHandle!=firstWinHandle){
 //To retrieve the handle of second window, extracting the handle which does not match to first window handle
 secondWinHandle=winHandle; //Storing handle of second window handle</p>

<p>//Switch control to new window
 driver.switchTo().window(secondWinHandle);</p>

<p>```</p>

<h3>SwitchTo Frame Command</h3>

<p>Purpose: WebDriver supports moving between named frames using the “switchTo” method.</p>

<p><code>
driver.switchTo().frame("frameName");
</code></p>

<h3>SwitchTo PopUp Command</h3>

<p>Purpose: WebDriver supports moving between named PopUps using the “switchTo” method. After you’ve triggered an action that opens a popup, you can access the alert and it will return the currently open alert object. With this object you can now accept, dismiss, read its contents or even type into a prompt. This interface works equally well on alerts, confirms, and prompts.</p>

<p><code>
Alert alert = driver.switchTo().alert();
</code></p>

<h3>Practice Exercise 1</h3>

<p>1) Launch new Browser</p>

<p>2) Open URL &ldquo;<a href="http://docs.seleniumhq.org/download/">http://docs.seleniumhq.org/download/</a>&rdquo;</p>

<p>3) Get Window name (Use GetWindowHandle command)</p>

<p>```
package practiceTestCases;
import java.util.Set;
import java.util.concurrent.TimeUnit;</p>

<p>import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;</p>

<p>public class PracticeSwitchWindow {</p>

<pre><code>    public static WebDriver driver;
    public static void main(String[] args) {

        // Create a new instance of the Firefox driver
        driver = new FirefoxDriver();

        // Put an Implicit wait, this means that any search for elements on the page could take the time the implicit wait is set for before throwing exception
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);

        // Launch the URL
        driver.get("http://docs.seleniumhq.org/download/");

        // Store and Print the name of the First window on the console
        String handle= driver.getWindowHandle();
        System.out.println(handle);

        // Close Original window
        driver.quit();

}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webdriver : Browser Navigation Commands]]></title>
    <link href="http://tabaolan1987.github.io/blog/2014/05/26/webdriver-browser-navigation-commands/"/>
    <updated>2014-05-26T08:53:47+07:00</updated>
    <id>http://tabaolan1987.github.io/blog/2014/05/26/webdriver-browser-navigation-commands</id>
    <content type="html"><![CDATA[<h2>WebDriver Browser Navigation Commands</h2>

<p>The navigate interface exposes the ability to move backwards and forwards in your browser’s history but navigate().to() and get() do exactly the same thing. One’s just a lot easier to type than the other.</p>

<!--more-->


<h3>To Command</h3>

<p>Purpose : This command is use to navigate on specific page or URL in between the  test Command : driver.navigate().to(URL); Parameters : url – The URL to load. It is best to use a fully qualified URL.</p>

<p><code>
driver.navigate().to("http://www.gooogle.com");
</code></p>

<h3>Forward Command</h3>

<p>Purpose : This command is use to go on to next page like browser’s forward button.</p>

<p><code>
driver.navigate().forward();
</code></p>

<h3>Back Command</h3>

<p>Purpose : This command is use to go back to previous page like browser’s back button.</p>

<p><code>
driver.navigate().back();
</code></p>

<h3>Practice Exercise</h3>

<p>1) Launch new Browser</p>

<p>2) Open Selenium docs website</p>

<p>3) Click on About link ( On top navigation)</p>

<p>4) Come back to Home page (Use ‘Back’ command)</p>

<p>5) Again go back to About page (This time use ‘Forward’ command)</p>

<p>6) Again come back to Home page (This time use ‘To’ command)</p>

<p>7) Refresh the Browser (Use ‘Refresh’ command)</p>

<p>8) Close the Browser</p>

<h4>Solution</h4>

<p>```
package automationFramework;</p>

<p>import java.util.concurrent.TimeUnit;</p>

<p>import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;</p>

<p>public class PracticeNavigationCommands {</p>

<pre><code>private static WebDriver driver = null;
public static void main(String[] args) {

    // Create a new instance of the Firefox driver
    driver = new FirefoxDriver();

    // Open Selenium website
    driver.get("http://docs.seleniumhq.org/");

    // Put an Implicit wait on driver
    driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);

    // Click on About link
    driver.findElement(By.Xpath("//a[contains(@href, '/about/')]")).click();

    // Go back to Home Page
    driver.navigate().back();

    // Go forward to About page
    driver.navigate().forward();

    // Go back to Home page
    driver.navigate().to("http://docs.seleniumhq.org/");

    // Refresh browser
    driver.navigate().refresh();

    // Close browser
    driver.close();
}
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
